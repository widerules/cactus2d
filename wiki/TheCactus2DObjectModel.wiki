#summary The Cactus2D Object Model

= The Cactus2D Object Model =

In the development of a game, it is necessary to represent all the elements that are part of it. These elements are called game objects, which can be characters, weapons, vehicles, among others. However not all the game objects are likely to be viewed on screen, because some are invisible and only serves to control. The game objects are the real entities of the game, because they suffer events and perform actions.

In addition to the game objects, it must also be set the different behaviors of each one of them. For this reason, some engines use an object model based in inheritance / specialization. In this model, shown in Figure 1, the classes that represent game objects must inherit from a core class, often called GameObject. Thus, a game object can be seen as a reusable container of features and basic attributes such as position and orientation, for example.


<a href="http://sertaogames.files.wordpress.com/2012/02/figure-1.png"><img class="size-full wp-image-310 " title="Figure 1" src="http://sertaogames.files.wordpress.com/2012/02/figure-1.png?w=584" alt=""   /></a>Figure 1. Inherated/Specialization Model of Game Objects.

For more specific objects, this approach requires the creation of subclasses to implement the specific features. Thus, when we need to model more complex objects, we get stuck on inheritance, since some objects need to inherit from more than one class, thus requiring a model with multiple inheritance, as shown in Figure 2. Not very often you need to have the same behaviors in game objects that are on different sides of the class hierarchy, and in addition, good practice guidance to the objects do not recommend overuse of inheritance due to various problems of reuse that entails.


Figure 2. Multiply Inherated in Inherated/Specialization Model.

For more specific objects, this approach requires the creation of subclasses to implement the specific features. Thus, when we need to model more complex objects, we get stuck on inheritance, since some objects need to inherit from more than one class, thus requiring a model with multiple inheritance, as shown in Figure 2. Not very often you need to have the same behaviors in game objects that are on different sides of the class hierarchy, and in addition, good practice guidance to the objects do not recommend overuse of inheritance due to various problems of reuse that entails.


Figure 3. Componentization Model of Game Objects.

In this model, it is possible to add and remove behaviors to a single game object, even at runtime, and also combine different behaviors. This last feature is what avoids the need of multiple inheritance and keeps the model closer to the real world, so that any object can have specific and / or common features, if compared to other game objects. In the example of figure 3, if it was necessary to instantiate an object of the car type, but with the behavior of rocket (a rocket car), we just add two components to the game object in use. This does not prevent them from having an object only with the car behavior and another object with only rocket behavior.

Cactus2D is a game engine that uses this componentization concept. It comes with several reusable components, but there’s also the possibility for the developer to create his own components, for any game can require specific components. There’s a class called GameObject that has a list of objects of the type Component. Every new behavior / feature that the game should require must extend the Component class. Yet every component inherits methods that are responsible for the game loops (update, physicsUpdate and render, for example). So, Cactus2D takes the responsibility of updating the game objects, receiving the player inputs, checking up the physics and rendering the changes.